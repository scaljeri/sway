{"./src/data/activerecord.js":{"calledFunctions":11,"calledLines":67,"code":["// Create the namespace -> JS load order independent","window.Sway = window.Sway || {};","window.Sway.data = window.Sway.data || {};","","(function (ns) {","    \"use strict\";","","    /*","     A reference to all registered model classes is kept here for two reasons, 1) you only need to define it once and","     2) relations can be created when available","     */","    var models = {}","    /**","     * Sway.data.ActiveRecord is the pattern used for this ORM implementation and based on the Ruby on Rails (RoR)","     * <a href=\"http://guides.rubyonrails.org/association_basics.html\">ActiveRecord Associations</a>. This pattern","     * encapsulates access to its resources, like a database or REST interface.<br>","     * This class is a helper class, it creates new Model classes of type {{#crossLink \"Sway.data.Model\"}}{{/crossLink}}","     * and serves as a blue print for all models. It gives them all they need to perform CRUD-like tasks","     *","     *      var webSql = new WebSqlStorage() ;                          // WebSql persistence","     *      var UserModel = new ActiveRecord( 'User', webSql, [","     *                            new Field( {type: 'TEXT', key: 'username', friendlyName: 'User name'})","     *                          , new Field( {type: 'TEXT', key: 'password', friendlyName: 'Password'})","     *                          , new Field( {type: 'DATE', key: 'birthday', friendlyName: 'Birthday'})","     *                          , new Field( { key: 'posts', type: 'has_many', friendlyName: 'Posts', model: 'Post'})","     *                      ]) ;","     *","     *      var PostModel = new ActiveRecord( 'Post', webSql, [","     *                            new Field( {type: 'Text', key: 'comment', friendlyName: 'Comment'})","     *                            , new Field( {type: 'belongs_to', model: 'User'} )","     *                      ]) ;","     *","     *      var userRecord = new UserModel() ;","     *","     * To avoid problems with Model associations, make sure all involved models are created before any usage. A defined model can be accessed","     * as follows","     *","     *      var UserModel = ActiveRecord.get( 'User' ) ;","     *","     * @class Sway.data.ActiveRecord","     * @constructor","     * @param {String} modelName name of the model","     * @param {Object} storage  object used to access the underlying data structure","     * @param {Array}  fields  list of {{#crossLink \"Sway.data.Field\"}}{{/crossLink}}s and {{#crossLink \"Sway.data.Relation\"}}{{/crossLink}}s","     */","        , ActiveRecord = function (modelName, storage, fields) {","            var Model = createModel(modelName);","","            appendStaticProperties(Model, storage, fields);","            appendPrototypeProperties(Model);","","            models[modelName] = Model;","","            return Model;","        };","    /**","     * Returns a model class","     * @method get","     * @static","     * @param {String} modelName name of the model","     * @return {Class} a model","     */","    ActiveRecord.get = function (modelName) {","        return models[modelName];","    };","","","    /* Define the Model class here */","","    /**","     * Use the Model class to create instances which represent your data records. These will speed up your develement","     * when CRUD-like tasks need to be done.<br>","     * To create a Model class, use {{#crossLink \"Sway.data.ActiveRecord\"}}{{/crossLink}}.","     *","     * <h3>The basics</h3>","     * To perform a search, a couple of static methods are available. Use the <tt>findByX</tt> methods to search on","     * a specific field","     *","     *     UserModel.findByUsername('John', function(userRecord) {"," *          // this === UserModel"," *     }) ;","     *","     * Of course, the same can be achieved using the more general search method","     *","     *     UserModel.find( {username: 'John'}, function(userRecord) {"," *          // this === UserModel"," *     }) ;","     *","     * With <tt>find</tt> it is also possible to define more fields to search for.<br>","     * A Model instance, on the otherhand, can be used to create or manipulate data","     *","     *     userRecord = new User() ;                            // create a blank record","     *     userRecord.username = 'John' ;                       // set the username","     *     userRecord.password = 'Secret' ;                     // set the password","     *     userRecord.save(successCallback, errorCallback) ;    // check the result, because this action might fail","     *","     * <h3>Multiple result-sets</h3>","     * In {{#crossLink \"Sway\"}}{{/crossLink}} a Model instance can also represent multiple records. Although it always","     * represent a single record, internally this has the whole result set.","     *","     * its current","     * state will always be a single record, it is possible to navigate from one state to an other","     *","     *     User.search({username: 'John'}, function(record) {   // record is a model instance representing more than on result"," *           while( record.hasNext() ) {                    // check if there is an other record"," *                record.next() ;                           // move on record up"," *                ...."," *           }"," *           record.item(1) ;                               // go to second record"," *           record.prev() ;                                // go to first record. Use 'prev' in combination with 'hasPrev'"," *     }) ;","     *","     * <h3>Advanced</h3>","     *","     *","     *","     * An instance represents one or more records, which depends on how it was created. For example, if a database search returns multiple records,","     * the Model instance represent them all, holding in its current state the first record's values","     *","     *      User.find({ username: 'John' }, function(ar) {  // ActiveRecord instance, holding multiple records"," *          console.log(\"Found \" + ar.length + \" records) ;"," *      }) ;","     *","     * Checkout {{#crossLink \"Sway.data.Model/next:method\"}}{{/crossLink}}, {{#crossLink \"Sway.data.Model/prev:method\"}}{{/crossLink}}","     * {{#crossLink \"Sway.data.Model/item:method\"}}{{/crossLink}} and {{#crossLink \"Sway.data.Model/hasNext:method\"}}{{/crossLink}} to","     * understand how to deal with multi-record result-sets.","     *","     *","     *     var userRecord = new User({username: 'John', password: 'Secret'}) ;","     *     ....","     *     userRecord.save() ;","     *","     * All fields are accessible as a property of a record","     *","     *     var userRecord = new User() ;","     *     userRecord.username = 'John' ;","     *     userRecord.password = 'Secret' ;","     *","     * @class Sway.data.Model","     */","    var DEFAULTS = {","            /**","             * a record can be in two states; NORMAL (default) or TRANSFORMED ...... TODO","             *","             *      userRecord.setState(User.TRANSFORMED, callback) ; // change the state of the record","             *","             * @property {Object} STATE","             */","            STATE: {","                /**","                 * @property {Number} STATE.TRANFORMED","                 * @static","                 */","                TRANSFORMED: 1","                /**","                 * @property {Number} STATE.NORMAL","                 * @static","                 */, NORMAL: 0","            }","        }","        , STATIC = {","            /**","             * Use find to perform searches","             *","             *      User.find( {","             *           'username':   'John'","             *           , 'password': 'Secret'","             *      }, function(user) { ... } ) ;","             *","             * Or simply create a new instance of a Model and use it for a search or save action","             *","             *      var userRecord = new User({ username: 'John', password: 'Secret'}) ;","             *      User.find(userRecord, callback) ;","             *      // or","             *      userRecord.save() ;","             * @method find","             * @static","             * @param {Object} data JSON or model instance","             * @param {Object} [options] configuration","             *  @param {Boolean} [lazy=true] If false, <tt>find</tt> returns a model which will have all its data, including foreign key data, loaded.","             *  If the record is <tt>lazy</tt>, call {{#crossLink \"Sway.data.Model/load:method\"}}{{/crossLink}} first to make the data avaiable.","             */","            find: function (record, callback) {","                if (record.$className) {                                              // json required for searching","                    record = record.toJSON();","                }","                var json = this.storage.find(record, loadJSON.bind(this, callback));","                if (typeof(json) === 'object') {                                      // not async ?","                    var inst = new this(json, {state: DEFAULTS.STATE.TRANSFORMED});","                    if (inst.setState(DEFAULTS.STATE.NORMAL, callback)) {             // detect if async ? TODO","                        return inst;","                    }","                }","            }","            /**","             * save json data instead of an active record","             * @method save","             * @static","             * @param {Object} data json data","             * @param {Object} options","             * @return {Object} active record","             */, save: function (json, callback) {","                // for performance (no instance required","            }","            /**","             * Load relations for defined field(s). By default relations are lazy loaded.","             * @method include","             * @static","             * @param {Array} fieldNames define the relations which should be loaded","             * @return Model class","             * @example","             ModeClass.include('comments').findByName('John') ;","             */, include: function (fieldName) {","                return {","                    //find","                };","            }","        }","","    /**","     * @method item","     */","    /**","     * @method hasNext","     */","        , INSTANCE = {","            /**","             * @method getState","             */","            getState: function () {","                return this.__state__;","            }","            /**","             * change the state of a record. See ......","             * @method setState","             * @param state","             * @param {Boolean} [isLazy=true] values are transformed into the new state when requested. If <tt>true, all","             * values are transformed immediately.","             * @param {Function} [callback] if <tt>isLazy</tt> is set to TRUE the callback is called when all values","             * are transformed.","             */, setState: function (state, isLazy, callback) {","                this.state = state;","                if (typeof(isLazy) === 'function') {","                    callback = isLazy;","                    isLazy = true;","                }","                // TODO: applie transformers","                callback();","            }","            /**","             *","             * returns all data in JSON format","             * @method toJSON","             * @return {Object}","             */, toJSON: function () {","                return this.__data;","            }","            /**","             * Save the data and its relations","             * @method save","             * @param {Object} [options] configuration","             * @param {Function} [options.success] success callback function","             * @param {Function} [options.error] error callback function","             *","             */","            , save: function (options) {","                //return this.constructor.storage.save(this, deep, callback) ;","            }","            , getFields: function () {","                return this.constructor.fields;","            }","            /**","             * load all properties of the model instance.","             * @method load","             * @param {Function} [callback] callback function, called when the data is available","             * @param {Object} [options] configuration options","             *  @param {Boolnea} [options.lazy=true] lazy loading","             */","            , load: function (callback, options) {","                var json = {};","                if (this.fields[key].FK) {","                    json[key] = this[key];","                    this.fields[key].model.find(json, function (records) {","                        this[key] = records;","                        callback(this);","                    }.bind(this));","                }","            }","            /**","             * set all values back to their original value","             * @method reset","             * @chainable","             * return {Object} self","             */","            , reset: function () {","","            }","            /**","             * Call this function to make it aware of changes made to the data it relates to. Because a Model instance","             * has no direct link with, for example, a database, this mechanism only works when all changes made to the data are performed","             * by one and the same storage object. This storage object is responsible for the notifications.","             *","             * Always call {{#crossLink \"Sway.data.Model/unlink:method\"}}{{/crossLink}} to disable this behavior, or when the Model instance","             * otherwise, the","             * If the record or this <tt>link</tt> is not needed anymore, make sure to remove by calling {{#crossLink \"Sway.data.Model/unlink:method\"}}{{/crossLink}},","             * @method link","             */","            , link: function () {","","            }","            /**","             * @method unlink","             */, unlink: function () {","","            }, getLength: function () {","                return this.__dataSet.length;","            }","        };","","","    /* Private helpers */","","    /**","     * @class Sway.data.Model","     * @constructor","     * @param {Object} [data] ActiveRecord object or JSON data","     * @param {Object} [options]","     *      @param {String} [options.state] initial state","     */","    function createModel(modelName) {","        var model = function Model(data, options) {                              // define the model class/function","            options = options || {};                                         // fix input","            data = data || {};","","            if (data.$className) {                                        // check if data is an ActiveRecord instance","                data = data.toJSON();","            }","","            Object.defineProperty(this, '__state__',","                {","                    value: typeof(options.state) === 'boolean' ? options.state : DEFAULTS.STATE.NORMAL, enumarable: false","                });","            Object.defineProperty(this, '__id__',                    // if none of the fields is unique, this field is","                {                                                    // added to the record","                    value: null, enumarable: false, writable: true","                });","","            Object.defineProperty(this, '__data',","                {","                    value: data, writable: false                    // make only the properties of data writable","                });","","            Object.defineProperty(this, '$className',                // name of the class it belongs too","                {","                    value: modelName, writable: false","                });","","            /**","             * bla bla","             * @property {Boolean} isDirty","             */","            Object.defineProperty(this, 'isDirty',{value: false} ) ;","            Object.defineProperty(this, '__isNew',{value: true} ) ;","","","            /**","             * bla bla","             * @property {Boolean} isNew","             */","            Object.defineProperty(this, 'isNew',{","                set: isNew.bind(this)","                , get: isNew.bind(this)","            }) ;","","            var field, i;","            for (i in this.constructor.fields) {","                field = this.constructor.fields[i];","                (function (i, field) {","                    Object.defineProperty(this, i, {","                        set: function(value){field.set( this, i, value);}.bind(this)    // set is handled by the field itself","                        , get: getProperty.bind(this, i)","                    });","                    if ( this.__data[i] === undefined ) { // set default value","                        this.__data[i] = field.defaultValue ;","                    }","                }.bind(this))(i, field);","","","            }","            return Object.preventExtensions(this);                               // make sure no properties can be added","        };","        model.$name = modelName ;","        return model ;","    }","","","    function getProperty(key) {","        return this.__data[key];","    }","","    function appendStaticProperties(Model, storage, fields) {","        var i","            , field","            , hasPK = false;                                    // used to determine if a PK is defined, if not create findById function","","        for (i in STATIC) {                                   // create static methods","            Model[i] = STATIC[i].bind(Model);","        }","","        /*","         A relation needs to be set on both object. For example, if a patient has an address, an address belongs to","         a patient. In code","         patient.address = address ;","         address.__reverseRelation.belongs_to['patient'] = this ; // note that","         */","        Object.defineProperty(Model, '__reverseRelation', { value: {}, enumarable: false}) ;","","        Model.storage = storage;                                   // reference to the storage object","        Model.fields = {};                                         // field container, referenced by their key value","        Model.relations = {};                                         // field container, referenced by their key value","","        Object.defineProperty(Model, 'findLookup', {","            value: {}","            , enumerable: false","        }) ;","","        for (i = 0; i < fields.length; i++) {","            field = fields[i] ;","            Model.fields[field.key] = field;         // add field to fields object","            createFindByXXX(Model, field);","            hasPK = hasPK | !!field.PK;                // bitwise OR to determine if PK is defined (hasPK is 1 or 0)","","            if ( field.model ) { // if defined, its a relation between two models","                Model.__reverseRelation[field.model.$className||field.model] = field ;","            }","        }","","        if (hasPK === 0) {","            // TODO add id Field to Model too!!","            createFindByXXX(Model, new ns.Field('id', {autoIncrement: true }));","        }","    }","","    function createFindByXXX(Model, field) {","        var name = ['findBy', field.key.slice(0, 1).toUpperCase(), field.key.slice(1)].join('');","        Model[name] = (Model.findLookup[name] = findBy.bind(Model, field.key)) ;","    }","","    function appendPrototypeProperties(Model, data) {","        var i;","","        for (i in INSTANCE) {","            Model.prototype[i] = INSTANCE[i];                                // create instance function","        }","    }","","    function findBy(property, value) {","        console.log(\"find by \" + property + \" with value=\" + value);","    }","","    /*","     * loadJSON receives json from a storage object. It converts this into an active record object.","     */","    function loadJSON(callback, json) {","        var newRec = new this(json, {state: DEFAULTS.STATE.TRANSFORMED});","        newRec.__id__ = json.__id__;                                   // existing records get a unique id","        if (callback) {","            callback(newRec);                                              // return a new record","        }","        return newRec;","    }","","    function isNew(state) {","       if ( state === undefined )  {","           return this.__isNew ;","       }","       else if (state === false) {","           // TODO: remove PK value","           this.__isNew = true ;","       }","    }","","    ns.ActiveRecord = ActiveRecord;","","})(window.Sway.data);","","","","","","","","","",""],"coveredFunctions":23,"coveredLines":101,"functions":{"(anonymous 1):5":1,"(anonymous 2):283":0,"(anonymous 3):378":190,"ActiveRecord:46":9,"Model:331":60,"appendPrototypeProperties:449":9,"appendStaticProperties:401":9,"createFindByXXX:444":35,"createModel:330":9,"find:183":0,"findBy:457":0,"get:63":13,"getFields:269":0,"getLength:315":0,"getProperty:397":64,"getState:230":0,"include:213":0,"isNew:473":0,"load:279":0,"loadJSON:464":0,"set:380":85,"setState:241":0,"toJSON:255":0},"lines":{"12":1,"141":1,"184":0,"185":0,"187":0,"188":0,"189":0,"190":0,"191":0,"2":1,"214":0,"231":0,"242":0,"243":0,"244":0,"245":0,"248":0,"256":0,"270":0,"280":0,"281":0,"282":0,"283":0,"284":0,"285":0,"3":1,"316":0,"330":1,"331":9,"332":60,"333":60,"335":60,"336":0,"339":60,"343":60,"348":60,"353":60,"362":60,"363":60,"370":60,"375":60,"376":60,"377":190,"378":190,"379":190,"380":85,"383":190,"384":105,"390":60,"392":9,"393":9,"397":1,"398":64,"401":1,"402":9,"406":9,"407":27,"416":9,"418":9,"419":9,"420":9,"422":9,"427":9,"428":26,"429":26,"430":26,"431":26,"433":26,"434":17,"438":9,"440":9,"444":1,"445":35,"446":35,"449":1,"450":9,"452":9,"453":90,"457":1,"458":0,"464":1,"465":0,"466":0,"467":0,"468":0,"47":9,"470":0,"473":1,"474":0,"475":0,"477":0,"479":0,"483":1,"49":9,"5":1,"50":9,"52":9,"54":9,"6":1,"63":1,"64":13},"path":"/Volumes/DATA/dev/ws/zipped/src/data/activerecord.js"},"./src/data/field.js":{"calledFunctions":2,"calledLines":16,"code":["window.Sway = window.Sway || {}; // make sure it exists","window.Sway.data = window.Sway.data || {};","","(function (ns) {","    \"use strict\";","","    /**","     * A Field represents a single value of an {{#crossLink \"Sway.data.ActiveRecord\"}}{{/crossLink}} model.","     * It can represent a simple field definition, or an association; an relation between two models.","     *","     *     var username   = new Field('username', { friendlyName: 'User name' })","     *         , password = new Field('password', { type: 'password', friendlyName: 'Password' })","     *         , address  = new Field('address',  { key: 'address', type: 'belongs_to', model: Sway.data.Address, friendlyName: 'Address' }) ;","     *","     * Furthermore, a Field can also hold information about data transformation, which is used by the persistence layer","     *","     *     var accountInfo = new Field( 'accountInfo', { type: 'BLOB', friendLyName: 'Account info', transformers: [encryptFilter, compressFilter] }) ;","     *","     * <h3>Associations</h3>","     *","     * This Active Record implementation is based on the Ruby on Rails (RoR) <a href=\"http://guides.rubyonrails.org/association_basics.html\">ActiveRecord Associations</a>.<br>","     * The following associations are available:","     *","     * <h4>BELONGS_TO and HAS_ONE (THROUGH) Association</h4>","     * Assume an 'Account' <tt>belongs\\_to</tt> a 'Supplier'. Or the other way around, a Supplier <tt>has\\_one</tt> Account.","     * Furthermore, if an 'Account' and 'Supplier' both <tt>has\\_one</tt> 'AccountHistory', it could look like this","     *","     *      var Account = new Sway.data.ActiveRecord( 'Account', storage, [","     *            new Sway.data.Relation({ key: 'supplier', type: 'belongs_to', model: 'Supplier' }       // creates a field 'supplier_id'","     *            new Sway.data.Relation({ type: 'has_one', model: 'AccountHistory' }                     // AccountHistory should have a account_id field","     *            .....","     *      ]) ;","     *","     *      var Supplier = new Sway.data.ActiveRecord( 'Supplier', storage, [","     *           new Sway.data.Relation({ key: 'account', type: 'has_one', model: 'Account' })","     *           new Sway.data.Relation({ key: 'accountHistory', type: 'has_one', through: 'AccountHistory', model: 'Account' })","     *           ....","     *      ]) ;","     *","     *      var AccountHistory = new Sway.data.ActiveRecord( 'AccountHistory', storage, [","     *          new Sway.datat.Relation({ type: 'belongs_to', model: 'Account' })                          // creates an 'account_id' field","     *          ...","     *      ]) ;","     *","     *      ...","     *      supplierRecord.accountHistory = someAccountHistories","     *","     * An <tt>belongs_to</tt> field is always required!!","     *","     * <h4>HAS_MANY (THROUGH)</h4>","     * This association define a one-to-many or a many-to-many relationship.","     *","     *      new Sway.data.Relation({ key: 'orders', type: 'has_many', model: 'Order' }) ;            // one-to-many","     *      new Sway.data.Relation({ key: 'patients', type: 'has_many', through: 'Appointment', model: 'Patient' }) ;  // many-to-many","     *","     * <h4>HAS_AND_BELONGS_TO_MANY</h4>","     * This relation is identical to <tt>HAS\\_MANY THROUGH</tt> (many-to-many), except it doesn't have a third model","     *","     *      new Sway.data.Relation({ key: 'assemblies', type: 'has_and_belongs_to_many', model: 'Assembly' })","     *","     * And the association in the other moddel look like","     *","     *      new Sway.data.Relation({ key: 'parts', type: 'has_and_belongs_to_many', model: 'Part' })","     *","     *","     * @class Sway.data.Field","     * @constructor","     * @param {String} key name of the field","     * @param {Object} [options] definition of this field","     *      @param {String}  [options.type=TEXT] type of the field or association","     *      @param {String}  [options.model] referenced model","     *      @param {String}  [options.through] specifies a join model. Only available for <tt>HAS\\_ONE</tt> and <tt>HAS\\_MANY</tt> associations","     *      @param {String}  [options.friendlyName] description of the field","     *      @param {Boolean} [options.PK=false] primary key field (there can only be one primary key field)","     *      @param {Boolean} [options.autoIncrement=true] Primary key field is auto-incremented (auto generated key)","     *      @param {Boolean} [options.index=false] put an index on the field","     *      @param {Boolean} [options.unique=false] unique field","     *      @param {Array}   [options.compoundIndex] names of the compound index it is part of.","     *      @param {Boolean} [options.required=false] a required field","     *      @param {Array}   [options.transformers] list of transformer objects. A transformer object can transform the data into a new form and also back","     * into its original form. Think of, zipping and unzipping or encrypting and decrypting","     *      @param {Array}   [options.validators] list of validation functions","     */","    var Field = function (key, options) {","        if (!options) {","            options = {};","        }","        for (var i in options) {","            this[i] = options[i];","        }","        this.key = key;","        this.type = options.type || 'text';  // define default type","","        return Object.freeze(this);","    };","","    /* this function is called by ActiveRecord, which will also be the context/this */","    function set(key, value) {","        this[key] = value ;","    }","","    Field.prototype = {","","        set: function(value) {","","        },","        /**","         * @method transform","         * @param {*} value value to be transformed","         * @param {Function} callback function called with the transformed data","         */","        transform: function (value, callback) {","            if (this.transformers) {","                transform(0, this.transformers, callback, value);","            }","            else {","                callback(value);","            }","        }","        /**","         * @method validate","         * @param {*} value value to be validated","         * @return {Boolean}","         */, validate: function (value) {","            var i","                , ok = true;","","            if (this.validators) {","                for (i = 0; i < this.validators.length; i++) {","                    if (!this.validators[i].validate(value)) {","                        ok = false;","                        break;","                    }","                }","            }","            return ok;","        }, isField: function () {","            return true;","        }","        /*","         * Returns the size of","         * @method size","         */","        /*","         , getSize: function() {","         return this.state === \"uncompressed\" ? encodeURI(this._inputStr).split(/%..|./).length - 1 : this._zippedBlob.size ;","         }","         */","    };","","    function transform(index, transformers, callback, value) {","        if (transformers[index]) {","            transformers[index].transform(value, transform.bind(null, ++index, transformers, callback));","        }","        else {","            callback(value);","        }","    }","","    ns.Field = Field;","","})(window.Sway.data);","",""],"coveredFunctions":7,"coveredLines":31,"functions":{"(anonymous 1):4":1,"Field:84":18,"isField:137":0,"set:98":0,"transform:112":0,"transform:151":0,"validate:124":0},"lines":{"1":1,"102":1,"113":0,"114":0,"117":0,"125":0,"128":0,"129":0,"130":0,"131":0,"132":0,"136":0,"138":0,"151":1,"152":0,"153":0,"156":0,"160":1,"2":1,"4":1,"5":1,"84":1,"85":18,"86":8,"88":18,"89":10,"91":18,"92":18,"94":18,"98":1,"99":0},"path":"/Volumes/DATA/dev/ws/zipped/src/data/field.js"},"./src/data/persistance/websqlresult.js":{"calledFunctions":3,"calledLines":12,"code":["window.Sway = window.Sway || {} ; // make sure it exists","window.Sway.data = window.Sway.data || {} ;","window.Sway.data.persistance = window.Sway.data.persistance || {} ;","","(function(ns){","    /**","     * @class Sway.data.persistance.WebSqlResult","     * @param {Object} WebSql result","     * @param {Object} [model]","     */","    var WebSqlResult = function(result, model) {","        this.result = result ;","        this.model  = model ;","        this.length = result.rows.length ;","","    } ;","    WebSqlResult.prototype = {","        /**","         * @method forEach","         * @param {Function} callback","         */","        forEach: function(callback) {","            for( var i = 0; i < this.result.rows.length; i++) {","                callback(this.model ? new this.model(this.result.rows.item(i)) : this.result.rows.item(i), i) ;","            }","        }","    } ;","","    ns.WebSqlResult = WebSqlResult ;","})(window.Sway.data.persistance) ;"],"coveredFunctions":3,"coveredLines":12,"functions":{"(anonymous 1):5":1,"WebSqlResult:11":2,"forEach:22":2},"lines":{"1":1,"11":1,"12":2,"13":2,"14":2,"17":1,"2":1,"23":2,"24":6,"29":1,"3":1,"5":1},"path":"/Volumes/DATA/dev/ws/zipped/src/data/persistance/websqlresult.js"},"./src/data/relation.js":{"calledFunctions":5,"calledLines":42,"code":["// Create the namespace -> JS load order independent","window.Sway = window.Sway || {};","window.Sway.data = window.Sway.data || {};","","(function (ns) {","    /*","        *) Rule nr1: Only one relation can exist between two tables","","     belongs_to ( === foreign key ) (http://stackoverflow.com/questions/3808926/whats-the-difference-between-belongs-to-and-has-one)","     has_one","     has_many","     has_many :through   (the thirt table is also a model)","     has_one :through    ( goes one-to-one through other model)","     has_and_belongs_to_many    // simple linker table (http://stackoverflow.com/questions/2780798/has-and-belongs-to-many-vs-has-many-through)","     */","","    /**","     * Sway.data.Relation defines the association between two {{#crossLink \"Sway.data.Model\"}}{{/crossLink}}s. It is based on the Ruby on Rails (RoR)","     * <a href=\"http://guides.rubyonrails.org/association_basics.html\">ActiveRecord Associations</a>.<br>","     * The following associations are available:","     *","     * <h4>BELONGS_TO and HAS_ONE (THROUGH) Association</h4>","     * Assume an 'Account' <tt>belongs\\_to</tt> a 'Supplier'. Or the other way around, a Supplier <tt>has\\_one</tt> Account.","     * Furthermore, if an 'Account' and 'Supplier' both <tt>has\\_one</tt> 'AccountHistory', it will look like this","     *","     *      var Account = new Sway.data.ActiveRecord( 'Account', storage, [","     *            new Sway.data.Relation({ key: 'supplier', type: 'belongs_to', model: 'Supplier' }       // creates a field 'supplier_id'","     *            new Sway.data.Relation({ type: 'has_one', model: 'AccountHistory' }                     // AccountHistory should have a account_id field","     *            .....","     *      ]) ;","     *","     *      var Supplier = new Sway.data.ActiveRecord( 'Supplier', storage, [","     *           new Sway.data.Relation({ key: 'account', type: 'has_one', model: 'Account' })","     *           new Sway.data.Relation({ key: 'accountHistory', type: 'has_one', through: 'AccountHistory', model: 'Account' })","     *           ....","     *      ]) ;","     *","     *      var AccountHistory = new Sway.data.ActiveRecord( 'AccountHistory', storage, [","     *          new Sway.datat.Relation({ type: 'belongs_to', model: 'Account' })                          // creates an 'account_id' field","     *          ...","     *      ]) ;","     *","     *      ...","     *      supplierRecord.accountHistory = someAccountHistories","     *","     * An <tt>belongs_to</tt> field is always required!!","     *","     * <h4>HAS_MANY (THROUGH)</h4>","     * This association define a one-to-many or a many-to-many relationship.","     *","     *      new Sway.data.Relation({ key: 'orders', type: 'has_many', model: 'Order' }) ;            // one-to-many","     *      new Sway.data.Relation({ key: 'patients', type: 'has_many', through: 'Appointment', model: 'Patient' }) ;  // many-to-many","     *","     * <h4>HAS_AND_BELONGS_TO_MANY</h4>","     * This relation is identical to <tt>HAS\\_MANY THROUGH</tt> (many-to-many), except it doesn't have a third model","     *","     *      new Sway.data.Relation({ key: 'assemblies', type: 'has_and_belongs_to_many', model: 'Assembly' })","     *","     * And the association in the other moddel look like","     *","     *      new Sway.data.Relation({ key: 'parts', type: 'has_and_belongs_to_many', model: 'Part' })","     *","     * @class Sway.data.Relation","     * @constructor","     * @param {String} key","     * @param {String} type type of association","     * @param {String} model name of the model","     * @param {Object} [options]","     *          @param {String} [options.through] specifies a join model. Only available for <tt>HAS\\_ONE</tt> and <tt>HAS\\_MANY</tt> associations","     *          @param {String} [options.friendlyName] description of the field","     */","    var Relation = function (key, type, model, options) {","        if ( !options ) {","            options = {} ;","        }","        this.key = key;","        this.type = type;","        this.model = model;","        this.defaultValue = options.defaultValue||null ;","","        switch (type) {","            case 'belongs_to' :","                this.set = setHasOne.bind(this) ;        // force context === this","                this.defaultValue = options.defaultValue||null ;","                break ;","            case 'has_one':","                this.set = setHasOne.bind(this) ;","                this.defaultValue = options.defaultValue||null ;","                break ;","            case 'has_many':","                this.set = setHasMany.bind(this) ;","                this.defaultValue = options.defaultValue||[] ;","                break;","            case 'has_and_belongs_to_many':","                this.set = setHasMany.bind(this);","                this.defaultValue = options.defaultValue||[] ;","                break;","            default:","                this.set = function(){ throw(\"Associtation \" + type  + \" is not supported\");};","        }","","        return Object.freeze(this);","    };","","    Relation.prototype = {} ;","","    /*","        @param {Object} self the object which receives the 'activeRecord'","        @param {String} key the property of self","        @param {Object} activeRecord the value to be set","     */","    function setHasOne(self, key, activeRecord) {","        console.log(self.$className + ':' + key + ' has-one ' + activeRecord.$className) ;","        self.__data[key] = activeRecord ;","        setSelf2AR(self, key, activeRecord) ;","    }","    function setHasMany(self, key, activeRecord) {","        console.log(self.$className + ':' + key + ' has-many ' + activeRecord.$className) ;","        var i;","","        if ( Array.isArray(activeRecord) ) {","            self.__data[key] = activeRecord ;","            for( i = 0; i < activeRecord.length; i++) {","                setSelf2AR(self, key, activeRecord) ;","            }","        }","        else if ( self.__data[key].indexOf(activeRecord) === -1 ) {","            self.__data[key].push(activeRecord) ;","            setSelf2AR(self, key, activeRecord) ;","        }","    }","","    function setSelf2AR(self, key, activeRecord) {","        var otherField = activeRecord.constructor.__reverseRelation[self.$className] ;","        if ( otherField ) {","            if ( activeRecord[otherField.key] !== self ) {","                activeRecord[otherField.key] = self ;","            }","        }","        else {  // nope, no relation!!","            throw \"No Relation defined for \" + self.$className + \":belongs_to --> \" + activeRecord.$className + \":???\" ;","        }","    }","","    ns.Relation = Relation;","})(window.Sway.data);"],"coveredFunctions":6,"coveredLines":47,"functions":{"(anonymous 1):5":1,"Relation:72":17,"set:99":0,"setHasMany:117":50,"setHasOne:112":30,"setSelf2AR:133":60},"lines":{"102":17,"105":1,"112":1,"113":30,"114":30,"115":30,"117":1,"118":50,"119":50,"121":50,"122":0,"123":0,"124":0,"127":50,"128":30,"129":30,"133":1,"134":60,"135":60,"136":60,"137":50,"141":0,"145":1,"2":1,"3":1,"5":1,"72":1,"73":17,"74":1,"76":17,"77":17,"78":17,"79":17,"81":17,"83":6,"84":6,"85":6,"87":5,"88":5,"89":5,"91":4,"92":4,"93":4,"95":2,"96":2,"97":2,"99":0},"path":"/Volumes/DATA/dev/ws/zipped/src/data/relation.js"},"./src/di.js":{"calledFunctions":10,"calledLines":52,"code":["window.Sway = window.Sway || {} ; // make sure it exists","","(function(ns, console, DEBUG) {","","    var depCheck = []                                   // used to check for circular dependencies","    /**","     * DI makes classes accessible by a contract. Instances are created when requested and dependencies are injected into the constructor,","     * facilitating lazy initialization and loose coupling between classes.","     *","     * As an example, register all contracts during the application initialization","     *","     *      var di = new Sway.DI() ;","     *      di.register( 'UserModel'                                                                            // contract name","     *                   , Sway.data.ActiveRecord                                                               // class definiton","     *                   , [ 'User', 'webSql', ['userNameField', 'passwordField', 'accountInfo'], 'websql' ]    // constructor parameters","     *                   , { singleton: TRUE }                                                                  // configuration: create a singleton","     *                 )","     *        .register( 'userNameField'","     *                   , Sway.data.Field","     *                   , [{ type: 'TEXT',  key: 'username', friendlyName: 'User name' }]","     *                   , {singleton: TRUE}","     *                 )","     *        .register( 'accountInfoField',","     *                   , Sway.data.Field","     *                   , [ { type: 'TEXT',  key: 'username', friendlyName: 'User name' }","     *                        , ['encryptFilter', 'compressFilter']","     *                     ]","     *                   , { singleton: TRUE}","     *                 )","     *        .register( 'userRecord'","     *                   , di.getInstance('UserModel')  // create the User model!!","     *                 )","     *        ...","     *","     * Now everywhere in the application create the instances as follows","     *","     *       var User = Sway.di.getInstance('User') ;","     *       userRecord = new User({ username: 'John', password: 'Secret' }) ;","     *       // or","     *       userRecord = Sway.di.getInstance('userRecord', [{username: 'John', password: 'Secret'}]) ;","     *","     * To give an idea of what this does, below is an example doing the exact same thing but without Sway.DI","     *","     *       var userNameField    = new Sway.data.Field( { type: 'TEXT',  key: 'username', friendlyName: 'User name' }] ) ;","     *       var accountInfoField = new Sway.data.Field( { type: 'TEXT',  key: 'username', friendlyName: 'User name' }","     *                                                   , [encryptFilterInstance, compressFilterInstance] ) ;","     *       ...","     *","     * And create instances like","     *","     *       var User = new Sway.data.ActiveRecord( 'User', webSqlInstance, [userNameField, passwordField, accountInfoField] ) ;","     *       var userRecord = new User({username: 'John', password: 'Secret'}) ;","     *","     * @class Sway.DI","     * @constructor","     **/","     , di = function() {","        // container for all registered classes","        Object.defineProperty(this, '_contracts',","            {","                value: {},","                enumerable: false // hide it","            }","        ) ;","    } ;","","    di.prototype = {","        /**","         * Register a class by creating a contract. Use {{#crossLink \"Sway.DI/getInstance:method\"}}{{/crossLink}} to obtain","         * an instance from this contract. The <tt>params</tt> parameter is a list of contracts,  and, if needed, normal","         * constructor parameters can be mixed in.","         *","         * @method register","         * @chainable","         * @param {String} contract name of the contract","         * @param {Class} classRef the class bind to this contract","         * @param {Array} [params] list of constructor parameters. Only if a parameter is a string and matches a contract, it","         * will be replaced with the corresponding instance","         * @param {Object} [options] configuration","         *      @param {String} [options.singleton=false] create a new instance every time","         *      @param {String} [options.description] describes the contract (currently only used by {{#crossLink \"Sway.DI/listContracts:method\"}}{{/crossLink}}).","         * @return {Object} this","         * @example","         App.di.registerType(\"ajax\", App.AJAX) ;","         App.di.registerType(\"ajax\", App.AJAX, [], { singleton: true }) ;","         App.di.registerType(\"util\", App.Util, [\"compress\", true, [\"wsql\", \"ls\"] ], { singleton: true } ) ;","         **/","        register: function(contract, classRef, params, options)","        {","            if ( params && !Array.isArray(params) ) { // fix input","                options = params ;","                params = [] ;","            }","","            this._contracts[contract] = { classRef: classRef, params: params||[], options: options||{} } ;","            return this ;","        },","","        /**","         * Returns an instance for the given contract. Use <tt>params</tt> attribute to overwrite the default","         * parameters for this contract. If <tt>params</tt> is defined, the singleton configuration option is ignored.","         *","         * @method getInstance","         * @param  {String} contract name","         * @param  {Array} [params] constructor parameters which, if defined, replaces its default arguments (see {{#crossLink \"Sway.DI/register:method\"}}{{/crossLink}} )","         * @return {Object} Class instance","         * @example","         App.di.register(\"ajax\", [\"rest\"]) ;","         var ajax = App.di.getInstance(\"ajax\") ;","         ajax = App.di.getInstance(\"ajax\", [\"rest\", true]) ;    //","         **/","        getInstance: function(contract, params) {","            var instance = null ;","","            if ( this._contracts[contract]  ) {                                      // it should exist","                if (this._contracts[contract].options.singleton )","                {","                    instance = getSingletonInstance.call(this, contract, params) ;","                } else //create a new instance every time","                {","                    instance = createInstance.call(this, contract, params) ;","                }","            }","            return instance ;","        },","        /**","         * List all available contracts with their description to <tt>console.log</tt>","         * @method listContracts","         */","        listContracts: function() {","            var keys = Object.keys(this._contracts) ;","            keys.sort().forEach(function(v) {","               console(v + ', ' + this._contracts[v].options.description) ;","            }.bind(this)) ;","        }","    } ;","","    /* ***** PRIVATE HELPERS ***** */","","    /* Create or reuse a singleton instance */","    function getSingletonInstance(contract, params) {","        var config = this._contracts[contract] ;","        if ( params ) {","            config.params = params ;","        }","","        if ( config.instance === undefined || params ) {","            config.instance = createInstance.call(this, contract, config.params);","        }","        return config.instance ;","    }","","    /* convert a list of contracts into a list of instances","     * A dependency list can contain arrays with dependencies too:","     *    [\"depA\", [\"depB\", \"depC\"], \"depE\"]","     * In this case, the constructor would, for example, look like this:","     *    function constructor(instance, array, instance) { .. }","     * */","    function createInstanceList(contract, params) {","        var constParams = [] ;","","        (params||this._contracts[contract].params||[]).forEach( function(c) {","            if ( Array.isArray(c)) {","                constParams.push( createInstanceList.call(this, contract, c) ) ;","            }","            else {","                constParams.push( createInstanceIfContract.call(this, c) ) ;","            }","        }.bind(this)) ;","        return constParams ;","    }","","    function createInstanceIfContract(contract) { // is a contract","        var constParam = contract","            , problemContract ;","        if ( typeof(contract) === 'string' && this._contracts[contract] ) {     // is 'contract' just a contructor parameter or a contract?","            if ( depCheck.indexOf(contract) === -1 ) {                    // check for circular dependency","                //this._depCheck.push(contract) ;                               // add contract to circular dependency check list","                constParam = this.getInstance(contract) ;                       // create the instance","                depCheck.pop() ;                                          // done, remove dependency from the list","            }","            else { // circular dependency detected!! --> STOP, someone did something stupid -> fix needed!!","                problemContract = depCheck[0] ;","                depCheck.length = 0 ;                                     // cleanup","                throw \"Circular dependency detected for contract \" + problemContract ;","            }","        }","        return constParam ;","    }","","    /*","     * Returns a new instance of the class matched by the contract. If the contract does not exists an error is thrown.","     *","     * @method createInstance","     * @param {string} contract - the contract name","     * @param {Array} params - list of contracts passed to the constructor. Each parameter which is not a string or","     * an unknown contract, is passed as-is to the constructor","     *","     * @returns {Object}","     * @example","     var storage = App.di.createInstance(\"data\", [\"compress\", true, \"websql\"]) ;","     **/","    function createInstance(contract, params)","    {","        var instance = null","            , self = this","            , cr ;","","        function Dependency(){","            cr.apply(this, createInstanceList.call(self, contract, params)) ;","        }","","        if ( this._contracts[contract]) {           // contract should exist","            cr = this._contracts[contract].classRef ;","","            depCheck.push(contract) ;","            Dependency.prototype = cr.prototype ;   // Fix instanceof","            instance = new Dependency() ;           // done","            depCheck.pop() ;","        }","        else if ( DEBUG ) {","            console.warn( 'Contract ' + contract + ' does not exist') ;","        }","        return instance ;","    }","","    ns.DI = di ;","","})(window.Sway, window.console, window.Sway.DEBUG) ;"],"coveredFunctions":12,"coveredLines":57,"functions":{"(anonymous 1):3":1,"(anonymous 2):132":0,"(anonymous 3):162":24,"Dependency:209":10,"createInstance:203":10,"createInstanceIfContract:173":20,"createInstanceList:159":14,"di:57":6,"getInstance:112":16,"getSingletonInstance:141":14,"listContracts:130":0,"register:88":3},"lines":{"1":1,"113":16,"115":16,"116":16,"118":14,"121":2,"124":14,"131":0,"132":0,"133":0,"141":1,"142":14,"143":14,"144":1,"147":14,"148":8,"150":12,"159":1,"160":14,"162":14,"163":24,"164":4,"167":20,"170":12,"173":1,"174":20,"176":20,"177":8,"179":7,"180":6,"183":1,"184":1,"185":1,"188":18,"203":1,"205":10,"209":10,"210":10,"213":10,"214":10,"216":10,"217":10,"218":10,"219":8,"221":0,"222":0,"224":8,"227":1,"3":1,"5":1,"59":6,"67":1,"90":3,"91":1,"92":1,"95":3,"96":3},"path":"/Volumes/DATA/dev/ws/zipped/src/di.js"},"./src/eventhub.js":{"calledFunctions":28,"calledLines":152,"code":["window.Sway = window.Sway || {}; // make sure it exists","","(function (ns, DEBUG) {","    var DEFAULTS = {","            /**","             * Contains available event modes. For example, if <tt>bar.foo</tt> is triggered, both event modes do the opposite","             *","             *                    | |                                     / \\","             *     ---------------| |-----------------     ---------------| |-----------------","             *     | bar          | |                |     | bar          | |                |","             *     |   -----------| |-----------     |     |   -----------| |-----------     |","             *     |   |bar.foo   \\ /          |     |     |   |bar.foo   | |          |     |","             *     |   -------------------------     |     |   -------------------------     |","             *     |        Event CAPTURING          |     |        Event BUBBLING           |","             *     -----------------------------------     -----------------------------------","             *","             * The event model implemented in this class does both, going from <tt>bubbling</tt> to the execution of all callbacks in <tt>bar.foo</tt>,","             * then back in <tt>capturing</tt> mode","             *","             *                                   | |  / \\","             *                  -----------------| |--| |-----------------","             *                  | bar            | |  | |                |","             *                  |   -------------| |--| |-----------     |","             *                  |   |bar.foo     \\ /  | |          |     |","             *                  |   --------------------------------     |","             *                  |               event model              |","             *                  ------------------------------------------","             *","             *     eventHub.on('bar.foo', myFunc1) ;","             *     eventHub.on('bar', myFunc2, { eventMode: Sway.EventHub.EVENT_MODE.CAPTURING }) ;","             *     eventHub.on('bar', myFunc3, { eventMode: Sway.EventHub.EVENT_MODE.BUBBLING }) ;","             *     eventHub.on('bar', myFunc4, { eventMode: Sway.EventHub.EVENT_MODE.BOTH }) ;","             *     eventHub.trigger('bar.foo') ; // -> callback execution order: myFunc3, myFunc4, myFunc1, myFunc2 and myFunc4","             *","             * @property {Object} EVENT_MODE","             * @static","             * @example","             */","            EVENT_MODE: {","                /**","                 * Defines the capturing event mode","                 * @property {String} EVENT_MODE.CAPTURING","                 * @static","                 */","                CAPTURING: 'capture'           // event goes from root to target","                /**","                 * Defines the bubbling event mode","                 * @property {String} EVENT_MODE.BUBBLING","                 * @static","                 */","                , BUBBLING: 'bubble'            // event goes from target to root","                /**","                 * Represent both capturing and bubbling event modes","                 * @property {String} EVENT_MODE.BOTH","                 * @static","                 */","                , BOTH: 'both'","            }","            /* PRIVATE PROPERTY","             * Default setting, to allow the same callback to be registered multiple times to the same event","             */, ALLOW_MULTIPLE: true","        }","    /**","     * EventHub facilitates event-based communication between different parts of an application (Event driven system).","     * Events can be namespaced too.","     *","     * Namespaces are separated by a dot, like","     *","     *     bar.foo1","     *     bar.foo2","     *     bar.bar1.foo1","     *","     * A Namespace and an Eventname are actually more or less the same thing:","     *","     *     eventHub.on('bar', myFunc1) ;","     *     eventHub.on('bar.foo1', myFunc2) ;","     *     eventHub.on('bar.bar1', myFunc3) ;","     *     eventHub.on('bar.bar1.foo1', myFunc4) ;","     *","     * The advantage of namespaced events is that it facilitates triggering groups of events","     *","     *     eventHub.trigger('bar') ;        // --> triggers: myFunc1, myFunc2, myFunc3 and myFunc4","     *     eventHub.trigger('bar.bar1');    // --> triggers: myFunc3 and myFunc4","     *","     * @class Sway.EventHub","     * @constructor","     * @param {Object} [options] configuration parameters","     *      @param {Boolean} [options.allowMultiple=TRUE] accept multiple registrations of the same function for the same event","     */","        , Eventhub = function (options) {","            Object.defineProperty(this, '_rootStack',","                {","                    value: { __stack: { triggers: 0, on: [], one: []} }, enumerable: false // hide it","                }","            );","            Object.defineProperty(this, '_eventNameIndex',","                {","                    value: 0, enumerable: false // hide it","                    , writable: true    // otherwise ++ will not work","                }","            );","            this.allowMultiple = options && typeof(options.allowMultiple) === 'boolean' ? options.allowMultiple : DEFAULTS.ALLOW_MULTIPLE;","        };","","    Eventhub.EVENT_MODE = DEFAULTS.EVENT_MODE;                   // set static properies","","    Eventhub.prototype = {","        /**","         * Generates an unique event name","         * @method generateUniqueEventName","         * @return {String} unique event name","         */","        generateUniqueEventName: function () {","            return '--eh--' + this._eventNameIndex++;     // first event-name will be: --eh--0","        }","","        /**","         *","         * @method setAllowMultiple","         * @chainable","         * @param {Boolean} state accept multiple registrations of the same function for the same event","         */","        , setAllowMultiple: function (state) {","            this.allowMultiple = state;","            return this;","        }","        /**","         * Enable an event name. See {{#crossLink \"Sway.EventHub/disable:method\"}}{{/crossLink}}","         * @method enable","         * @chainable","         * @param {String} eventName name of the event","         * @param {Object} [options] configuration","         *  @param {Boolean} [options.traverse=false] disable nested events as wel if set to TRUE","         */","        , enable: function (eventName, options) {","            var namespace = getStack.call(this, eventName);","","            changeStateEvent.call(this, namespace || {}, false, options || {});","            return this;","        }","        /**","         * Disable an event. All triggers on a disabled event are ignored and no event propagation takes place. For example","         *","         *     eventHub.on('bar', callback1, { eventMode: Sway.EventHub.EVENT_MODE.BOTH }) ;","         *     eventHub.on('bar', callback2) ;","         *     eventHub.on('bar.foo', callback3, { eventMode: Sway.EventHub.EVENT_MODE.BOTH }) ;","         *     eventHub.on('bar.foo', callback4) ;","         *     eventHub.on('bar.foo.do', callback5 { eventMode: Sway.EventHub.EVENT_MODE.BOTH }) ;","         *     eventHub.on('bar.foo.do', callback6) ;","         *     eventHub.disable('bar') ;","         *","         *     eventHub.trigger('bar')          // -> no callbacks called","         *     eventHub.trigger('bar.foo')      // -> callback execution order: callback2, callback3, callback2","         *","         * @method disable","         * @chainable","         * @param {String} eventNname name of the event","         * @param {Object} [options] configuration","         *  @param {Boolean} [options.traverse=false] disable nested events as wel if set to TRUE","         */","        , disable: function (eventName, options) {","            var namespace = getStack.call(this, eventName);","","            changeStateEvent.call(this, namespace || {}, true, options || {});","            return this;","        }","        /**","         * check if a specific event is disabled.","         * @method isDisabled","         * @param {String} eventName name of the event","         * @return {Boolean} TRUE if the event is disabled. If the event does not exists, FALSE is returned","         */, isDisabled: function (eventName) {","            var namespace = getStack.call(this, eventName);","            return namespace ? namespace.__stack.disabled : false;","        }","","        /**","         * Triggers one or more events. One event is triggered if the 'eventName' parameter targets a specific event, but if this parameter is a namespace, all nested events and","         * namespaces will be triggered.","         *","         * @method trigger","         * @param {string} eventName name of the event or namespace","         * @param {*} data data passed to the triggered callback function","         * @param {Object} [options] configuration","         *      @param {Boolean} [options.traverse=false] trigger all callbacks in nested namespaces","         *      @param {String}  [options.eventMode] define the event mode to be used","         * @return {Number} the count of triggered callbacks","         * @example","         Sway.eventHub.trigger('ui.update' ) ;                                      // trigger the 'update' event inside the 'ui' namespace","         Sway.eventHub.trigger('ui', null, {traverse: true} ) ;                     // trigger all nested events and namespaces inside the 'ui' namespace","         Sway.eventHub.trigger('ui.update', {authenticated: true} ) ;               // trigger the 'update' event inside the 'ui' namespace","         Sway.eventHub.trigger('ui', {authenticated: true}, {traverse: true} ) ;    // trigger all nested events and namespaces inside the 'ui' namespace","         */","        , trigger: function (eventName, data, options) {","            var retVal = 0","                , namespace;","            if ((namespace = getStack.call(this, eventName)) && !!!namespace.__stack.disabled) {  // check if the eventName exists and not being disabled","                retVal = triggerEventCapture.call(this, eventName || '', data, options||{}) +              // NOTE that eventName can be empty!","                    triggerEvent(namespace, data, options || {}) +","                    ((eventName || '').match(/\\./) !== null ? triggerEventBubble(namespace, data, options||{}) : 0);","","                namespace.__stack.triggers++;                                             // count the trigger","                namespace.__stack.one = [];                                                // cleanup","            }","            return retVal;                                                                 // return the number of triggered callback functions","        }","","        /**","         * Register a callback for a specific event. Callbacks are executed in the order of","         * registration. Set 'prepend' to TRUE to add the callback in front of the others. With the 'options'","         * parameter it is also possible to execute the callback in a capturing or bubbling phase.","         *","         * @method on","         * @param {String} eventName","         * @param {Function} callback","         * @param {Object} [options] configuration","         *      @param {Boolean} [options.prepend] if TRUE, the callback is placed before all other registered callbacks.","         *      @param {String} [options.eventMode] the event mode for which the callback is triggered too. Available modes are","         *          <tt>capture</tt>, <tt>bubble</tt> or both","         * @return {Boolean} TRUE if the callback is registered successfully. It will fail if the callback was already registered","         * @example","         Sway.eventHub.on( 'ui.update', this.update.bind(this) ) ;","         Sway.eventHub.on( 'ui.update', this.update.bind(this), {prepend: true, eventMode: Sway.EventHub.EVENT_MODE.CAPTURING} ) ;","         */","        , on: function (eventName, callback, options) {","            return addCallbackToStack.call(this, eventName, callback, options || {}) !== null;","        }","","","        /**","         * Register a callback for a specific event. This function is identical to {{#crossLink \"Sway.EventHub/on:method\"}}{{/crossLink}}","         * except that this callback is removed from the list after it has been triggered.","         *","         * @method one","         * @param {string} eventName","         * @param {function} callback","         * @param {Object} [options] configuration","         *      @param {Boolean} [options.prepend] if TRUE, the callback is placed before all other registered callbacks.","         *      @param {String} [options.eventMode=null] the event mode for which the callback is triggered too. Available modes are","         *          <tt>capture</tt> and <tt>bubble</tt>","         * @return {Boolean} TRUE if the callback is registered successfully. It will fail if the callback was already registered","         */","        , one: function (eventName, callback, options) {","            var obj = addCallbackToStack.call(this, eventName, callback, options || {});","            if (obj) { // if obj exists, the callback was added.","                obj.isOne = true;","            }","            return obj !== null;","        }","","        /**","         * Removes the given callback for a specific event. However, if a callback is registered with an 'eventMode', the","         * callback can only be removed if that eventMode is specified too!","         *","         * @method off","         * @param {String} eventName","         * @param {Function} [callback] the callback function to be removed. If omitted, all registered events and nested","         * namespaces inside 'eventName' are removed","         * @param {Object} options configuration","         *      @param {Boolean} [options.traverse=false] traverse all nested namespaces","         *      @param {String} [options.eventMode=null] the event mode of the callback to be removed","         *      @param {Boolean} [options.isOne]","         * @return {Number} the count of removed callback functions","         * @example","         Sway.eventHub.off('ui.update', this.update) ;","         Sway.eventHub.off('ui.update', this.update, {eventMode: Sway.EventHub.EVENT_MODE.CAPTURING}) ;","         Sway.eventHub.off('ui') ;","         */","        , off: function (eventName, callback, options) {","            if ( typeof callback !== 'function' ) {                         // fix input","                options = callback ;","                callback = null ;","            }","            var stack = getStack.call(this, eventName);","            return removeFromNamespace(stack, callback, options || {});","        }","","        /**","         * count the registered callbacks for an event or namespace","         *","         * @method countCallbacks","         * @param {Sting} eventName the event name for which all registered callbacks are counted (including nested event names).","         * @param {Object} [options] configuration","         *      @param {String} [options.eventMode] the event mode; Sway.EventHub.CAPTURING or Sway.EventHub.BUBBLE","         *      @param {Boolean} [options.traverse=false] traverse all nested namepsaces","         * @return {Number} the number of callback functions inside 'eventName'. Returns -1 if the event or namespace does not exists","         * TODO: etype is not used","         */","        , countCallbacks: function (eventName, options) {","            if (!eventName) { // => count all callback function within this namespace","                (options = options || {}).traverse = true;","            }","            var namespace = getStack.call(this, eventName);","            return sumPropertyInNamespace(namespace, getCallbackCount, options || {});","        }","","        /**","         * returns the the trigger count for this event","         * @method countTrigger","         * @param {sting} [eventName] the event name","         * @param {Object} [options]","         *      @param {Boolean} [options.traverse=false] traverse all nested namepsaces","         * @return {Number} trigger count. -1 is returned if the event name does not exist","         */","        , countTriggers: function (eventName, options) {","            if (!eventName) { // => count all triggers","                (options = options || {}).traverse = true;","            }","            var stack = getStack.call(this, eventName);","            return sumPropertyInNamespace(stack, getTriggerCount, options || {});","        }","    };","","    /* ******** PRIVATE HELPER FUNCTION *********** */","","    /*","     * An event can be in two states: disabled or enabled. The 'state' parameter holds the new state. This state","     * will be applied to all nested events.","     * @param {Object} namespace","     * @param {Boolean} state TRUE to disable the events","     */","    function changeStateEvent(namespace, state, options) {","        var i;","","        for (i in namespace) {","            if (i === '__stack') {","                namespace.__stack.disabled = state;","            }","            else if (options.traverse) {","                changeStateEvent.call(this, namespace[i], state, options);","            }","        }","    }","","    /*","     Returns the sum of a stack property. The specific property is implemented in propertyFunc","     */","    function sumPropertyInNamespace(namespace, propertyFunc, options) {","        var i","            , retVal = 0;","","        for (i in namespace) {","            if (i === '__stack') {","                retVal += propertyFunc(namespace.__stack, options);","            }","            else if (options.traverse === true) {","                retVal += sumPropertyInNamespace(namespace[i], propertyFunc, options);","            }","        }","        return retVal;","    }","","    /*","     Returns the number of callback function present in this stack","     */","    function getCallbackCount(stack, options) {","        var i","            , retVal = 0;","        for (i in stack.on) {","            if (stack.on[i].eventMode === options.eventMode) {","                retVal++;","            }","        }","        return retVal;","    }","","    /*","     Returns the trigger count of this stack","     */","    function getTriggerCount(stack, options) {","        return stack.triggers;","    }","","    function addCallbackToStack(eventName, callback, options) {","        var obj = null","            , stack;","        if (checkInput(eventName, callback)) {                                     // validate input","            stack = createStack.call(this, eventName);                             // get stack of 'eventName'","            if (canAddCallback.call(this, stack.__stack.on, callback, options) === true) {                       // check if the callback is not already added","                obj = {","                    fn: callback,","                    eventMode: options.eventMode,","                    isOne: false","                };","                stack.__stack.on[options.prepend ? 'unshift' : 'push'](obj);","            }","        }","        return obj;","    }","","    /*","     determines if a callback can be added to a stack. If this.allowMultiple === true, it will always return true","     */","    function canAddCallback(callbacks, callback, options) {","        var i","            , retVal = true","            , eventMode = options.eventMode;//|| undefined ;","","        if (this.allowMultiple === false) {","            for (i = 0; i < callbacks.length; i++) {","                if (callbacks[i].fn === callback && (","                    callbacks[i].eventMode === eventMode ||                                 // they are identical","                        callbacks[i].eventMode && eventMode === DEFAULTS.EVENT_MODE.BOTH ||     // both defined and one set to 'BOTH'","                        eventMode && callbacks[i].eventMode === DEFAULTS.EVENT_MODE.BOTH )      // idem (switched)","                    ) {","                    retVal = false;","                    break;","                }","            }","        }","        return retVal;","    }","","","    /* Validate the input for 'on' and 'one'.","     eventName: should be defined and of type \"string\"","     callback:  should be defined and of type \"function\"","     */","    function checkInput(eventName, callback) {","        var retVal = false;","        if (typeof(eventName) === \"string\" && callback && typeof(callback) === \"function\") { // OK","            retVal = true;","        }","        else if (DEBUG) { // Wrong...","            console.warn(\"Cannot bind the callback function to the event nam ( eventName=\" + eventName + \",  callback=\" + callback + \")\");","        }","        return retVal;","    }","","    /*","     Removes the callback from the stack. However, a stack can contain other namespaces. And these namespaces","     can contain the callback too. Furthermore, the callback is optional, in which case the whole stack","     is erased.","     */","    function removeFromNamespace(namespaces, callback, options) {","        var retVal = 0                                              // number of removed callbacks","            , namespace","            , i;                                                       // loop var","","        for (i in namespaces) {                                         // so we loop through all namespaces (and __stack is one of them)","            namespace = namespaces[i];","            if (i === '__stack') {","                retVal += removeCallback(namespace.on, callback, options);","            }","            else if (options.traverse) {                              // NO, its a namesapace -> recursion","                retVal += removeFromNamespace.call(this, namespace, callback, options);","            }","        }","        return retVal;                                             // a count of removed callback function","    }","","    /* This function should only be called on a stack with the 'on' and 'one' lists. It will remove one or","     multiple occurrences of the 'callback' function","     */","    function removeCallback(list, callback, options) {","        var i                                             // position on the stack","            , retVal = 0;","","        for (i = list.length - 1; i >= 0; i--) {","            if ((list[i].fn === callback || !callback) && list[i].eventMode === options.eventMode","                && (options.isOne === list[i].isOne || options.isOne === undefined || options.isOne === null)","            /*","             && ( options.isOne === undefined || options.isOne === null || options.isOne === list[i].isOne","             || (options.isOne === false && list[i].isOne === undefined)","             )","             */","                ) {","                list.splice(i, 1);","                retVal++;","            }","        }","        return retVal;","    }","","    /*","     This private function returns the callback stack matched by 'eventName'. If the eventName does","     not exist 'null' is returned","     */","    function getStack(namespace) {","        var parts = namespace ? namespace.split('.') : []   // parts of the event namespaces","            , stack = this._rootStack                   // root of the callback stack","            , i;                                       // loop index","","        for (i = 0; i < parts.length; i++) {","            if (!stack[parts[i]]) {","                return null;                               // it does not exist -> done","            }","            stack = stack[parts[i]];                       // traverse a level deeper into the stack","        }","        return stack;                                      // return the stack matched by 'eventName'","    }","","    /*","     * Internally 'eventName' is always a namespace. Callbacks are placed inside a special","     * variable called '__stack'. So, when the eventName is 'doAction', internally this will","     * look like doAction.__stack. This function always increases the count for each namespace","     * because this function is only called when adding a new callback. Finally, if the namespace","     * does not exist, it is created.","     */","    function createStack(namespace) {","        var parts = namespace.split('.')                    // split the namespace","            , stack = this._rootStack                       // start at the root","            , i;                                           // loop index","","        for (i = 0; i < parts.length; i++) {                // traverse the stack","            if (!stack[parts[i]]) {                        // if not exists --> create it","                stack[parts[i]] = {","                    __stack: {                              // holds all info for this namespace (not the child namespaces)","                        on: []                              // callback stack","                        , parent: stack                     // parent namespace/object","                        , triggers: 0                       // count triggers","                        , disabled: false                   // by default the namespace/event is enabled","                    }","                };","            }","            stack = stack[parts[i]];                       // go into the (newly created) namespace","        }","        return stack;","    }","","    function triggerEventCapture(eventName, data, options) {","        var i","            , namespace = this._rootStack","            , parts = eventName.split('.') || []","            , eventMode = DEFAULTS.EVENT_MODE.CAPTURING","            , retVal = 0; // callCallbacks(namespace, eventMode) ; -> because you cannot bind callbacks to the root","","        if (parts.length > 1 && (!options.eventMode || options.eventMode === DEFAULTS.EVENT_MODE.BOTH || options.eventMode === DEFAULTS.EVENT_MODE.CAPTURING)) {","            for (i = 0; i < parts.length - 1; i++) {        // loop through namespace (not the last part)","                namespace = namespace[parts[i]];","                retVal += callCallbacks(namespace, data, eventMode);","            }","        }","        return retVal;","    }","","    function triggerEventBubble(namespace, data, options) {","        //var namespace = namespaces.__stack.parent ;","        var eventMode = DEFAULTS.EVENT_MODE.BUBBLING","            , retVal = 0;","","        if ( !options.eventMode || options.eventMode === DEFAULTS.EVENT_MODE.BOTH || options.eventMode === DEFAULTS.EVENT_MODE.BUBBLING) {","            while (namespace.__stack.parent) {","                namespace = namespace.__stack.parent;","                retVal += callCallbacks(namespace, data, eventMode);","            }","        }","        return retVal;","    }","","    /*","     * Namespaces can in theory be many levels deep, like: \"aaaaa.bbbbbb.cccccc._stack\"","     * To traverse this namespace and trigger everything inside it, this function is called recursively (only if options.traverse === true).","     */","    function triggerEvent(stack, data, options) {","        var retVal = 0","            , ns;                                                  // loop index","","        if (!stack.disabled) {                                    // if this node/event is disabled, don't traverse the namespace deeper","            for (ns in stack) {","                if (ns === \"__stack\") {","                    retVal += callCallbacks(stack, data);","                }","                else if (options.traverse) {                           // found a deeper nested namespace","                    retVal += triggerEvent(stack[ns], data, options);  // nested namespaces. NOTE that the 'eventName' is omitted!!","                }","            }","        }","        return retVal;","    }","","    /*","     This method triggers the callback for a given namespace. It does not traverse the namespaces, it only loops through","     the 'on' list and afterwards checks if there are callbacks which should be removed (checking the 'one' list)","     If the 'eventMode' is defined, it only triggers callbacks which accept the eventMode.","     @param {Object} namespace","     @param {Anything} data","     @param {String} eventMode accepted values","     */","    function callCallbacks(namespace, data, eventMode) {","        var i","            , retVal = 0","            , callback;","","        if (!namespace.__stack.disabled) {","            for (i = 0; i < namespace.__stack.on.length; i++) {           // loop through all callbacks","                callback = namespace.__stack.on[i];","                if (callback.eventMode === eventMode || eventMode && callback.eventMode === DEFAULTS.EVENT_MODE.BOTH ) { // trigger callbacks depending on their event-mode","                    retVal++;                                             // count this trigger","                    callback.fn(data);                                     // call the callback","                    if (callback.isOne) {","                        namespace.__stack.on.splice(i--, 1);               // remove callback for index is i, and afterwards fix loop index with i--","                    }","                }","            }","        }","        return retVal;","    }","","    ns.EventHub = Eventhub;","})(window.Sway, window.Sway.DEBUG);"],"coveredFunctions":28,"coveredLines":154,"functions":{"(anonymous 1):3":1,"Eventhub:90":34,"addCallbackToStack:374":48,"callCallbacks:580":50,"canAddCallback:394":48,"changeStateEvent:322":8,"checkInput:419":48,"countCallbacks:289":13,"countTriggers:305":14,"createStack:500":48,"disable:161":5,"enable:135":2,"generateUniqueEventName:113":3,"getCallbackCount:356":29,"getStack:479":81,"getTriggerCount:370":32,"isDisabled:172":6,"off:269":18,"on:225":46,"one:243":2,"removeCallback:455":30,"removeFromNamespace:435":30,"setAllowMultiple:123":4,"sumPropertyInNamespace:338":61,"trigger:194":23,"triggerEvent:555":19,"triggerEventBubble:537":10,"triggerEventCapture:521":18},"lines":{"1":1,"102":34,"105":1,"107":1,"114":3,"124":4,"125":4,"136":2,"138":2,"139":2,"162":5,"164":5,"165":5,"173":6,"174":6,"195":23,"197":23,"198":18,"202":18,"203":18,"205":23,"226":46,"244":2,"245":2,"246":2,"248":2,"270":18,"271":3,"272":3,"274":18,"275":18,"290":13,"291":1,"293":13,"294":13,"3":1,"306":14,"307":4,"309":14,"310":14,"322":1,"323":8,"325":8,"326":12,"327":8,"329":4,"330":1,"338":1,"339":61,"342":61,"343":105,"344":61,"346":44,"347":34,"350":61,"356":1,"357":29,"359":29,"360":158,"361":44,"364":29,"370":1,"371":32,"374":1,"375":48,"377":48,"378":48,"379":48,"380":36,"385":36,"388":48,"394":1,"395":48,"399":48,"4":1,"400":22,"401":48,"406":12,"407":12,"411":48,"419":1,"420":48,"421":48,"422":48,"424":0,"425":0,"427":48,"435":1,"436":30,"440":30,"441":50,"442":50,"443":30,"445":20,"446":12,"449":30,"455":1,"456":30,"459":30,"460":90,"468":26,"469":26,"472":30,"479":1,"480":81,"484":81,"485":116,"486":2,"488":114,"490":79,"500":1,"501":48,"505":48,"506":72,"507":12,"516":72,"518":48,"521":1,"522":18,"528":18,"529":9,"530":11,"531":11,"534":18,"537":1,"539":10,"542":10,"543":9,"544":20,"545":20,"548":10,"555":1,"556":19,"559":19,"560":19,"561":28,"562":19,"564":9,"565":1,"569":19,"580":1,"581":50,"585":50,"586":48,"587":220,"588":220,"589":72,"590":72,"591":72,"592":28,"597":50,"600":1,"91":34,"96":34},"path":"/Volumes/DATA/dev/ws/zipped/src/eventhub.js"}}
