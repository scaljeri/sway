{"./src/di.js":{"lines":{"2":1,"3":1,"11":1,"13":6,"20":6,"28":1,"48":17,"49":8,"50":8,"52":17,"53":17,"66":51,"67":51,"68":48,"70":19,"73":29,"76":42,"97":31,"98":1,"101":30,"102":30,"104":30,"105":30,"107":30,"108":30,"115":1,"116":19,"117":3,"119":19,"128":1,"129":35,"131":35,"132":41,"133":5,"136":36,"137":33,"138":33,"139":27,"140":1,"142":27,"145":3,"146":3,"150":25,"153":1},"functions":{"di:11":6,"register:46":17,"getInstance:65":51,"Fake:104":30,"createInstance:95":31,"getSingletonInstance:115":19,"(anonymous 2):131":41,"createInstanceList:128":35,"(anonymous 1):2":1},"coveredLines":44,"calledLines":44,"coveredFunctions":9,"calledFunctions":9,"path":"/Volumes/DATA/dev/ws/zipped/src/di.js","code":["","(function(console, Ns) {","    \"use strict\" ;","\t/**","\t\tDI makes classes accessible by a contract. Instances are created when requested and dependencies are injected into the constructor,","        facilitating lazy initialization and loose coupling between classes.","","\t\t@class Sway.DI","\t\t@constructor","\t**/","\tvar di = function() {","        // container for all registered classes","        Object.defineProperty(this, '_contracts',","            {","                value: {},","                enumerable: false // hide it","            }","        ) ;","        // used to check for circular dependencies","        Object.defineProperty(this, '_depCheck',","            {","                value:[],","                enumerable: false // hide it","            }","        ) ;","\t} ;","","\tdi.prototype = {","\t\t/**","\t\t * Register a class by creating a contract. Use {{#crossLink \"DI/getInstance:method\"}}{{/crossLink}} to obtain","         * an instance from this contract/class. The injected dependencies, if any, will be used as constructor parameter","         * in the order provided by the dependencies array.","         *","\t\t * @method register","\t\t * @chainable","\t\t * @param {String} contract name of the contracta","\t\t * @param {Class} class the class bind to this contract","         * @param {Array} [dependencies] list of contracts; dependencies of this class","         * @param {Object} [options] addition setting used to create the instance.","         * @param {string} options.singleton set to TRUE if the class should be treated as a singleton class","\t\t * @example","         App.di.registerType(\"ajax\", App.AJAX) ;","         App.di.registerType(\"ajax\", App.AJAX, [], { singleton: true }) ;","         App.di.registerType(\"util\", App.Util, [\"compress\", \"wsql\"], { singleton: true } ) ;","\t\t**/","        register: function(contract, classRef, dependencies, options)","        {","            if ( !options && !Array.isArray(dependencies) ) { // fix input","                options = dependencies ;","                dependencies = [] ;","            }","            this._contracts[contract] = { classRef: classRef, dependencies: dependencies, options: options||{} } ;","            return this ;","        },","","        /**","         * Returns an instance for the given contract.","         *","         * @method geInstancet","         * @param  {string} contract name","         * @returns {Object} Class instance","         * @example","         var ajax = App.di.getInstance(\"ajax\") ;","         **/","        getInstance: function(contract) {","            var instance = null ;","            if ( this._contracts[contract] ) {","                if (this._contracts[contract].options.singleton )","                {","                    instance = getSingletonInstance.call(this._contracts[contract]);","                } else //create a new instance every time","                {","                    instance = this.createInstance(contract, this._contracts[contract].dependencies) ;","                }","            }","            return instance ;","        },","","        /**","            Returns a new instance of the class matched by the contract. If the contract does not exists an error is thrown.","            If one of the dependencies does not exists, 'null' is used instead.","","            @method createInstance","            @param {string} contract - the contract name","            @param {Array} dependencies - list of contracts passed to the constructor","            @returns {Object}","            @example","                try {","                    var storage = App.di.createInstance(\"data\", [\"compress\", \"websql\"]) ;","                }","                catch(e) { // will fail if contract does not exist","                    console.log(e.name + ': ' + e.message) ;","                }","        **/","        createInstance: function(contract, dependencies)","        {","            if ( !this._contracts[contract] ) {","                throw 'Unknown contract name \"' + contract + '\"' ;","            }","","            var self = this ;","            var cr = this._contracts[contract].classRef ;","","            function Fake(){","                cr.apply(this, createInstanceList.call(self, contract, dependencies||[])) ;","            }","            Fake.prototype = cr.prototype ; // Fix instanceof","            return new Fake() ;","        }","\t} ;","","    /* ***** PRIVATE HELPERS ***** */","","    /* Create or reuse a singleton instance */","    function getSingletonInstance() {","        if (this.instance === undefined) {","            this.instance = new this.classRef(this.dependencies);","        }","        return this.instance ;","    }","","    /* convert a list of contracts into a list of instances","    * A dependency list can contain arrays with dependencies too:","    *    [\"depA\", [\"depB\", \"depC\"], \"depE\"]","    * In this case, the constructor would, for example, look like this:","    *    function constructor(instance, array, instance) { .. }","    * */","    function createInstanceList(contract, dependencies) {","        var instances = [] ;","","        dependencies.forEach( function(c) {","            if ( Array.isArray(c)) {","                instances.push( createInstanceList.call(this, contract, c) ) ;","            }","            else {","                if ( this._depCheck.indexOf(c) === -1 ) { // check for circular dependency","                    this._depCheck.push(c) ;","                    instances.push(this.getInstance(c)) ;","                    if ( !instances[instances.length-1]) {","                        console.warn(\"Dependency '\" + c + \"' does not exist!\") ;","                    }","                    this._depCheck.pop() ;","                }","                else { // fatal","                    this._depCheck.length = 0 ;","                    throw \"Circular dependency detected for contract \" + c ;","                }","            }","        }.bind(this)) ;","        return instances ;","    }","","\tNs.DI = di ;","","})(window.console, window.Sway) ;"]},"./src/eventhub.js":{"lines":{"1":1,"3":1,"4":1,"16":22,"22":22,"30":1,"41":0,"42":0,"45":0,"62":30,"63":30,"79":24,"93":26,"94":26,"95":23,"96":23,"98":3,"109":5,"110":5,"126":10,"127":10,"137":4,"138":4,"144":1,"145":12,"148":12,"149":15,"150":12,"153":3,"156":12,"159":1,"160":50,"162":50,"163":50,"164":50,"165":45,"166":45,"167":45,"170":5,"178":1,"179":50,"180":50,"182":0,"183":0,"184":0,"195":1,"196":10,"200":10,"201":10,"202":10,"203":10,"204":10,"205":10,"206":10,"209":0,"214":0,"216":10,"222":1,"223":32,"226":32,"227":32,"228":27,"229":27,"231":27,"233":32,"239":1,"240":0,"243":0,"244":0,"245":0,"247":0,"254":1,"255":49,"259":49,"260":68,"261":2,"263":66,"265":47,"275":1,"276":50,"280":50,"281":77,"282":31,"292":77,"294":50,"301":1,"302":41,"308":41,"309":46,"311":46,"312":35,"313":35,"314":34,"315":34,"316":34,"317":34,"318":12,"321":35,"324":11,"327":41,"330":1},"functions":{"eh:15":22,"defineEvent:40":0,"trigger:61":30,"on:78":24,"one:92":26,"count:108":5,"off:125":10,"triggerCount:136":4,"sumPropertyInNamespace:144":12,"addCallbackToStack:159":50,"checkInput:178":50,"removeFromStack:195":10,"removeCallback:222":32,"removeNameSpace:239":0,"getStack:254":49,"createStack:275":50,"triggerEvent:301":41,"(anonymous 1):3":1},"coveredLines":101,"calledLines":88,"coveredFunctions":18,"calledFunctions":16,"path":"/Volumes/DATA/dev/ws/zipped/src/eventhub.js","code":["window.Sway = window.Sway || {} ; // make sure it exists","","(function(Ns){","    var DEFAULTS = {","        CAPTURING:  'capturing'             // event goes from top to bottom","        , BUBBLING: 'bubbling'              // event goes from bottom to top","    }","    /**","     * EventHub facilitates event-based communication between different parts of an application (Event driven system).","     * Events can be namespaced too, checkout the jQuery <a href=\"http://docs.jquery.com/Namespaced_Events \">documentation</a> on how to use these namespaces.","     *","     * @class Sway.EventHub","     * @constructor","     */","        , eh = function() {","            Object.defineProperty(this, '_rootStack',","                {","                    value: { __stack: {count: 0, triggers: 0} }","                    , enumerable: false // hide it","                }","            ) ;","            Object.defineProperty(this, '_eventType',","                {","                    value: {}","                    , enumerable: false // hide it","                }","            ) ;","        } ;","","    eh.prototype = {","        /**","         * Change the behavior of an event. By default, only the callbacks registered to an event are triggered. But the event can","         * also be set to 'capturing' or 'bubbling' mode. Bubbling means the trigger starts at the root of the namespaces and bubbles","         * up to the event in question. Capturing does the opposite.","         *","         * @method defineEvent","         * @param eventName name of the event","         * @param etype event type. Supported options are: 'capturing' and 'bubbling'","         */","        defineEvent: function(eventName, etype) {","            if ( DEFAULTS.CAPTURING === etype || DEFAULTS.BUBBLING === etype ) {","                this._eventType[eventName] = etype ;","            }","            else {","                console.warn(\"Event type '\" + etype + \"' for '\" + eventName + \"' does not exist!\") ;","            }","        }","        ","        /**","         * Trigger one or more events. One event is triggered if the 'eventName' parameter targets a specific event, but if this parameter is a namespace, all nested events and","         * namespaces will be triggered.","         *","         * @method trigger","         * @param {string} eventName    name of the event or namespace","         * @param {Object|Array|Number|String|Boolean|Function} [data]   data passed to the triggered callback function","         * @return {Number} the count of triggered callbacks","         * @example","         Sway.eventHub.trigger('ui.update', {authenticated: true} ) ; // trigger the 'update' event inside the 'ui' namespace","         Sway.eventHub.trigger('ui', {authenticated: true} ) ;        // trigger all nested events and namespaces inside the 'ui' namespace","         */","        , trigger: function(eventName, data){","            var list = getStack.call(this, eventName) ;                 // load the stack for this namespace","            return triggerEvent(list, data) ;                // triggerEvent does the work of triggering everything (nested events & namespaces)","        }","","        /**","         * Register a callback to a specific event. Callbacks are executed in the order of","         * registration. Set 'prepend' to TRUE to add the callback in front of the others.","         *","         * @method on","         * @param {string} eventName","         * @param {function} callback","         * @param {boolean} [prepend] if TRUE, the callback is placed before all other registered callbacks.","         * @example","         Sway.eventHub.on( 'ui.update', this.update.bind(this) ) ;","         Sway.eventHub.on( 'ui.update', this.update.bind(this), true ) ;","         */","        , on: function(eventName, callback, prepend) {","            return addCallbackToStack.call(this, eventName, callback, prepend) !== null ;","        }","","","        /**","         * Register a callback to a specific event. This function is identical to {{#crossLink \"Sway.EventHub/on:method\"}}{{/crossLink}}","         * except that this callback is removed from the list after it has been triggered.","         *","         * @method one","         * @param {string} eventName","         * @param {function} callback","         * @param {boolean} [prepend] if TRUE, the callback is placed before all other registered callbacks.","         */","        , one: function(eventName, callback, prepend) {","            var stack = addCallbackToStack.call(this, eventName, callback, prepend) ;","            if ( stack ) { // if the stack exists, the callback was added to the 'on' list","                stack.__stack.one[prepend ? 'unshift':'push'](callback) ;   // and it should of course also be added to the 'one' list","                return true ;","            }","            return false ;","        }","","        /**","         * count the registered callbacks for an event or namespace","         *","         * @method count","         * @param {sting} [eventName] if empty all registered callbacks are counted","         * @return {Number} the number of callback functions inside 'eventName'. Returns -1 if the event or namespace does not exists","         */","        , count: function(eventName) {","            var stack = getStack.call(this, eventName) ;","            return sumPropertyInNamespace(stack, 'count') ;","        }","","        /**","         * Removes the given callback for a specific event.","         *","         * @method off","         * @param {string} eventName","         * @param {function} [callback] the callback function to be removed. If omitted, all registered events and nested","         * namespaces inside 'eventName' are removed","         * @return {Number} the count of removed callback functions","         * @example","         Sway.eventHub.off('ui.update', this.update) ;","         Sway.eventHub.off('ui') ;","         */","        , off: function(eventName, callback) {","            var stack = getStack.call(this, eventName) ;","            return removeFromStack(stack, callback) ;","        }","","        /**","         * returns the the trigger count for this event","         * @method triggerCount","         * @param {sting} [eventName] the event name","         * @return {Number} trigger count. -1 is returned if the event name does not exist","         */","        , triggerCount: function(eventName) {","            var stack = getStack.call(this, eventName) ;","            return sumPropertyInNamespace(stack, 'triggers') ;","        }","    } ;","","    /* ******** PRIVATE HELPER FUNCTION *********** */","","    function sumPropertyInNamespace(stack, property) {","        var i","            , sum = 0 ;","","        for( i in stack ) {","            if ( i === \"__stack\" ) {","                sum += stack[i][property] ;","            }","            else {","                sum += sumPropertyInNamespace(stack[i], property) ;","            }","        }","        return sum ;","    }","","    function addCallbackToStack(eventName, callback, prepend) {","        var stack ;","","        if ( checkInput(eventName, callback)) {                             // validate input","            stack = createStack.call(this, eventName) ;                      // get stack of 'eventName'","            if ( stack.__stack.on.indexOf(callback) === -1 ) {               // check if the callback is not already added","                stack.__stack.on[prepend ? 'unshift':'push'](callback) ;     // add callback","                stack.__stack.count ++ ;","                return stack ;","            }","        }","        return null ;","    }","","","    /* Validate the input for 'on' and 'one'.","        eventName: should be defined and of type \"string\"","        callback:  should be defined and of type \"function\"","     */","    function checkInput(eventName, callback) {","        if ( typeof(eventName) === \"string\" && callback && typeof(callback) === \"function\" ) { // OK","            return true ;","        }","        else if ( Ns.DEBUG ) { // Wrong...","            console.warn(\"Cannot bind the callback function to the event nam ( eventName=\" + eventName + \",  callback=\" + callback + \")\") ;","            return false ;","        }","    }","","","","    /*","        Removes the callback from the stack. However, a stack can contain other namespaces. And these namespaces","        can contain the callback too. Furthermore, the callback is optional, in which case the whole stack","        is erased.","     */","    function removeFromStack(stack, callback) {","        var retVal = 0                                              // number of removed callbacks","            , callbacks                                             // a stack with 'on' and 'one' (maybe)","            , ns ;                                                  // loop var","","        if ( callback ) {                                           // remove a specific callback","            for( ns in stack) {                                     // so we loop through all namespaces (and __stack is one of them)","                callbacks = stack[ns] ;","                if ( callbacks.on ) {                               // are we there yet, are we there yet","                    retVal += removeCallback(callbacks.on,  callback) ; // YES","                    callbacks.count -= retVal ;","                    removeCallback(callbacks.one, callback) ; // YES","                }","                else {                                              // NO, its a namesapace -> recurstion","                   retVal += removeFromStack.call(this, stack[callbacks], callback ) ;","                }","            }","        }","        else { // remove a whole namespace (no callback defined)","            retVal += removeNameSpace.call(this, stack)   ;","        }","        return retVal ;                                         // a count of removed callback function","    }","","    /* This function should only be called on a stack with the 'on' and 'one' lists. It will remove one or","       multiple occurrences of the 'callback' function","     */","    function removeCallback(list, callback){","        var position                                        // position on the stack","            , retVal = 0 ;                                  // number of removed callbacks","","        position = list.indexOf(callback) ;                 // is the callback in the callbacks list","        while( position > -1 ) {                            // but the callback can be present multiple times!","            retVal ++ ;                                     // found one match","            list.splice(position, 1) ;                      // remove callback from the stack","","            position = list.indexOf(callback) ;             // prepare the while check to see if more actions are required","        }","        return retVal ;","    }","","    /*","       Remove a whole namespace.","     */","    function removeNameSpace(stack) {","        var retVal = 0                                      // number of removed callbacks","            , i ;                                           // loop var","","        for( i in stack )  {                                // delete all elements from the stack (and we cannot do stack = {} ;)","            retVal += stack[i].count ;","            delete stack[i] ;                               // cleanup","        }","        return retVal ;","    }","","    /*","        This private function returns the callback stack matched by 'eventName'. If the eventName does","        not exist 'null' is returned","     */","    function getStack(namespace) {","        var parts = namespace ? namespace.split('.') : []   // parts of the event namespaces","                , stack = this._rootStack                   // root of the callback stack","                , i ;                                       // loop index","","        for( i = 0; i < parts.length; i++ ) {","            if ( ! stack[parts[i]]) {","                return null ;                               // it does not exist -> done","            }","            stack = stack[parts[i]] ;                       // traverse a level deeper into the stack","        }","        return stack ;                                      // return the stack matched by 'eventName'","    }","","    /*","     * Internally 'eventName' is always a namespace. Callbacks are placed inside a special","     * variable called '__stack'. So, when the eventName is 'doAction', internally this will","     * look like doAction.__stack. This function always increases the count for each namespace","     * because this function is only called when adding a new callback. Finally, if the namespace","     * does not exist, it is created.","     */","    function createStack(namespace) {","        var parts = namespace.split('.')                    // split the namespace","            , stack = this._rootStack                       // start at the root","            , i ;                                           // loop index","","        for(i = 0; i < parts.length ; i++) {                // traverse the stack","            if ( !stack[parts[i]] ){                        // if not exists --> create it","                stack[parts[i]] = {","                    __stack: {                              // holds all info for this namespace (not the child namespaces)","                        on: []                              // callback stack","                        , one: []                           // callbacks which are triggered only once","                        , parent: stack                     // parent namespace/object","                        , count: 0                          // count callbacks in this namespace","                        , triggers: 0                      // count triggers","                    }","                } ;","            }","            stack = stack[parts[i]] ;                       // go into the (newly created) namespace","        }","        return stack ;","    }","","    /*","     * Namespaces can in theory be many levels deep, like: \"aaaaa.bbbbbb.cccccc._stack\"","     * To traverse this namespace and trigger everything inside it, this function is called recursively.","     */","    function triggerEvent(namespaces, data) {","        var namespace                                               // current namespace in the loop","            , retVal = 0                                            // the number of called callback function","            , ns                                                    // loop index","            , i                                                     // loop index","            , callback ;                                            // callback from the on list","","        for( ns in namespaces ) {","            namespace = namespaces[ns] ;","","           if ( namespace.on ) {                                    // special namespace (it hold 'on' and 'one')","               namespace.triggers ++ ;","               for( i = namespace.on.length -1; i >= 0; i-- ) {     // loop through all callbacks","                  callback = namespace.on[i] ;","                  retVal ++ ;                                       // count this trigger","                  callback(data) ;                                  // call the callback","                   if ( namespace.one.indexOf(callback) > -1 ) {    // check if it is a 'one' callback","                       namespace.count -= removeCallback(namespace.on, callback) ;     // YES -> remove it from 'on'","                   }","               }","               namespace.one.length = 0 ;                           // all 'one' callbacks have been called --> cleanup","           }","           else {                                                   // found a deeper nested namespace","                retVal += triggerEvent(namespace, data) ;           // nested namespaces","           }","        }","        return retVal ;","    }","","    Ns.EventHub = eh ;","","})(window.Sway) ;"]},"./src/data/field.js":{"lines":{"1":1,"2":1,"4":1,"5":1,"12":1,"13":0,"15":0,"21":0,"30":1,"36":0,"42":0,"50":0,"58":0,"65":0,"69":1},"functions":{"f:12":0,"getValue:35":0,"getFilteredValue:41":0,"setValue:49":0,"setFilteredValue:57":0,"getSize:64":0,"(anonymous 1):4":1},"coveredLines":15,"calledLines":7,"coveredFunctions":7,"calledFunctions":1,"path":"/Volumes/DATA/dev/ws/zipped/src/data/field.js","code":["window.Sway = window.Sway || {}; // make sure it exists","window.Sway.data = window.Sway.data || {};","","(function (Ns) {","    \"use strict\" ;","","    /**","     *","     * @class Sway.data.Field","     * @param {Array} [filters] list of filters","     */","     var f = function (filterList) {","        this.filterList = filterList ;","","        Object.defineProperty(this, '_value',","            {","                value: null","                , enumerable: false // hide it","            }","        ) ;","        Object.defineProperty(this, 'value',","            {","                value: null","                , set: this.setValue","                , get: this.getValue","            }","        ) ;","    } ;","","    f.prototype = {","        /**","         * @method getValue","         * @returns {*}","         */","        getValue: function() {","            return this._value ;","        }","        /**","         * @method getFilteredValue","         */","        , getFilteredValue: function() {","            return this._value ;","","        }","        /**","         * @method setValue","         * @param {Object|String|Blob|Array} value the value of the field instance","         */","        , setValue: function(input) {","            this._value = input ;","","        }","        /**","         * @method setFilteredValue","         * @param {Object|String|Blob|Array} value the filtered value of the field instance","         */","        , setFilteredValue: function(input) {","            this._value = input ;","","        }","        /**","         * @method size","         */","        , getSize: function() {","            return this.state === \"uncompressed\" ? encodeURI(this._inputStr).split(/%..|./).length - 1 : this._zippedBlob.size ;","        }","    } ;","","    Ns.Field = f ;","","})(window.Sway.data) ;","",""]},"./src/data/activerecord.js":{"lines":{"2":1,"3":1,"5":1,"6":1,"18":1,"24":4,"33":4,"39":4,"45":4,"53":1,"60":2,"63":2,"71":2,"74":2,"75":2,"81":2,"88":2,"89":2,"90":2,"91":2,"94":2,"102":3,"105":6,"106":6,"114":2,"118":2,"119":1,"122":1,"123":2,"126":1,"137":1,"138":2,"141":2,"142":0,"145":2,"147":2,"148":4,"150":2,"153":1},"functions":{"ActiveRecord:18":4,"bless:59":2,"getField:101":3,"setField:104":6,"getSize:113":2,"clone:137":2,"(anonymous 1):5":1},"coveredLines":39,"calledLines":38,"coveredFunctions":7,"calledFunctions":7,"path":"/Volumes/DATA/dev/ws/zipped/src/data/activerecord.js","code":["// Create the namespace -> JS load order independent","window.Sway = window.Sway || {} ;","window.Sway.data = window.Sway.data || {} ;","","(function(Ns) {","    \"use strict\" ;","","    /**","     * This class stores a string in memory. If a persistance dependency is defined, it will use this dependency to store","     * the data. Filters are used to perform some action on the data before persisting it and on retrieval.","     * As an example, a persistance dependency could be WebSQL storage. A filter could be encryption and/or compression.","     * Note that for an encryption filter, it will perform an action on the data before persisting it, and on retrieval.","     *","     * @class Sway.data.ActiveRecord.","     * @param {Object}[persistence] dependency which can persist the data","     * @param {Array} [fieldList] list of filters. Depending on the filter type its a before and/or after filter.","     */","     var ActiveRecord = function(persistance ) {","","        /*","        AR prototype methods can be access by a BLESSED model, or simply by an ActiveRecord instance. To make these","        function independent of this BLESSED mechanism the blow variables is used within each function","         */","        Object.defineProperty(this, '_ar',          // use this._ar instead of this","            {","                value:this","                , configurable: false","                , writable: false","                , enumerable: false // hide it","            }","        ) ;","","        Object.defineProperty(this, '_persist',","            {","                value: persistance","                , enumerable: false // hide it","            }","        ) ;","        Object.defineProperty(this, '_field',","            {","                value: []","                , enumerable: false // hide it","            }","        ) ;","        Object.defineProperty(this, '_fieldLookup',","            {","                value: {}","                , enumerable: false // hide it","            }","        ) ;","    } ;","","\tActiveRecord.prototype = {","        /**","         * @method bless","         * @chainable","         * @param {Object} model instance to be blessed","         */","        bless: function(model) {","            var i","                , setup ;","","            Object.defineProperty(model, '_ar',             // create a ref to ActiveRecord instance","                {","                    value: this","                    , enumerable: false // hide it","                }","            ) ;","","            // copy methods","            model.save = this.save ;","","            // clone the fields","            if ( !model._field ) {","                Object.defineProperty(model, '_field',             // create a ref to ActiveRecord instance","                    {","                        value: []","                        , enumerable: false // hide it","                    }","                ) ;","                Object.defineProperty(model, '_fieldLookup',             // create a ref to ActiveRecord instance","                    {","                        value:{}","                        , enumerable: false // hide it","                    }","                ) ;","","                for( i = 0; i < this._field.length; i++ ){","                    setup = this._field[i] ;","                    model._fieldLookup[setup.key] = model._field.length ;","                    model._field.push(clone(this._field[i])) ;","                }","            }","            return this ;","        }","        /**","         * @method getField","         * @param {String} key","         * @return {Object} Field instance","         */","        , getField: function(key) {","            return this._field[this._fieldLookup[key]].field ;","        }","        , setField: function(key, field) {","           this._fieldLookup[key] = this._field.length ;","            this._field.push({ key: key, field: field}) ;","        }","        /**","         * @method getSize","         * @param {String} key","         * @returns {Number}","         */","        , getSize: function(key) {","            var self = this._ar","                , size = 0","                , i ;","","            if ( key ) {","                return self._field[self._fieldLookup[key]].field.getSize() ;","            }","            else {","                for( i = 0; i < self._field.length; i++ ) {","                    size += self._field[i].field.getSize() ;","                }","            }","            return size ;","            /*","            return (this.state == \"uncompressed\" ?","                        new Blob([this._inputStr], { type: \"text/plain\"}) : this._zippedBlob","                   ).size ;","            */","        },","        save: function() {","        }","    } ;","","    function clone (obj){","        var key","            , temp ;","","        if(obj === null || typeof(obj) !== 'object') {","            return obj;","        }","","        temp = obj.constructor();                           // changed","","        for(key in obj) {                                   // copy every attribute","            temp[key] = obj[key] ;","        }","        return temp;","    }","","\tNs.ActiveRecord = ActiveRecord ;","","})(window.Sway.data) ;"]}}